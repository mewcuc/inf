def dv(N): # превращение числа в восьмибитное двоичное
    n = bin(N)[2:]
    if len(n) == 8:
        return 0
    while len(n) < 8:
        n = '0' + n
    return n
                                          # Автомат обрабатывает целое число N (0 ≤ N ≤ 255) по следующему алгоритму
                                          # 1. Строится восьмибитная двоичная запись числа N
for N in range(0, 256):                   # 2. Все цифры двоичной записи заменяются на противоположные (0 на 1, 1 на 0).
    n = dv(N)                             # 3. Полученное число переводится в десятичную запись.
    A = n.replace('0', 'E')               # 4. Из нового числа вычитается исходное, полученная разность выводится на экран.
    n = A.replace('1', '0')
    nn = n.replace('E', '1')
    nndec = int(nn, 2)
    it = nndec - N
    if it == 113:
        print(N)

##################################################################################################################################

def tr(n):
    res = ''
    if n == 0:
        return  0
    while n > 0:
        m = n % 3
        res = str(m) + res
        n = n // 3
    return res

def per(n): # перевод из троичной системы счисления в десятиричную
    res = 0
    for i in range(len(n)):
        res = res * 3 + int(n[i])
    return res

mas = []

for N in range(1, 1000):
    n = tr(N)
    if N % 3 == 0:
        m = n[-2:]
        n += m
    elif N % 3 != 0:
        su = (n.count('1') + (n.count('2') * 2)) * 3
        n = n + tr(su)

    r = per(n)
    if r % 2 != 0 and r > 208:
        mas.append(r)

print(min(mas))


